# [15. 浮動小数点演算、その問題と制限](https://docs.python.jp/3/tutorial/floatingpoint.html)

< [Python チュートリアル](https://docs.python.jp/3/tutorial/index.html) < [ドキュメント](https://docs.python.jp/3/index.html)

## 浮動小数点数は2進数表現

> 浮動小数点数は、計算機ハードウェアの中では、基数を 2 とする (2進法の) 分数として表現されています。例えば、小数0.125は、 1/10 + 2/100 + 5/1000 という値を持ちますが、これと同様に、2 進法の分数0.001は 0/2 + 0/4 + 1/8 という値になります。これら二つの分数は同じ値を持っていますが、ただ一つ、最初の分数は基数 10 で記述されており、二番目の分数は基数 2 で記述されていることが違います。

0.125と0.001が同じ値を持つとはどういう意味か？さっぱりわからない。

## 不正確

> 残念なことに、ほとんどの小数は 2 進法の分数として正確に表わすことができません。その結果、一般に、入力した 10 進の浮動小数点数は、 2 進法の浮動小数点数で近似された後、実際にマシンに記憶されます。

### 近似

> 最初は基数 10 を使うと問題を簡単に理解できます。分数 1/3 を考えてみましょう。分数 1/3 は、基数 10 の分数として、

近似すると`0.3`になる。さらに近似すると0.33, 0.333, と続く。

> 何個桁数を増やして書こうが、結果は決して厳密な 1/3 にはなりません。しかし、少しづつ正確な近似にはなっていくでしょう。

> 基数を 2 とした表現で何桁使おうとも、10 進数の 0.1 は基数を 2 とした小数で正確に表現することはできません。基数 2 では、1/10 は循環小数 (repeating fraction) となります

> どこか有限の桁で止めると、近似値を得ることになります。

#### float

> 近年の殆どのコンピュータでは float 型は、分子に最も重大なビットから始めて最初の 53 ビットを使い、分母に 2 の累乗を使った、二進小数を使って近似されます。1/10 の場合は、二進小数は 3602879701896397 / 2 ** 55 となります。これは、1/10 に近いですが、厳密に同じ値ではありません。

## 丸め

> 値が表示される方法のために、ほとんどのユーザは、近似に気づきません。Python はマシンに格納されている二進近似値の10進小数での近似値を表示するので、格納されている値が元の10進小数の近似値でしか無いことを忘れがちです。ほとんどのマシンで、もし Python が2進数で近似された 0.1 の近似値をそのまま10進数で表示していたら、その結果は次のようになったでしょう

```python
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
```

> これは、ほとんどの人が必要と感じるよりも多すぎる桁数です。なので、Python は丸めた値を表示することで、桁数を扱いやすい範囲にとどめます

```python
>>> 1 / 10
0.1
```

> 表示された結果が正確に 1/10 であるように見えたとしても、実際に格納されている値は最も近く表現できる二進小数であるということだけは覚えておいてください。

これは結構怖い。

## 近似値を表示する

> 幾つかの異なる10進数の値が、同じ2進有理数の近似値を共有しています。例えば、0.1 と 0.10000000000000001 と 0.1000000000000000055511151231257827021181583404541015625 はどれも 3602879701896397 / 2 ** 55 に近似されます。同じ近似値を共有しているので、どの10進数の値も eval(repr(x)) == x という条件を満たしたまま同じように表示されます。

> 昔の Python は、プロンプトと repr() ビルトイン関数は 17 桁の有効数字を持つ 0.10000000000000001 のような10進数の値を選んで表示していました。 Python 3.1 からは、ほとんどの場面で 0.1 のような最も短い桁数の10進数の値を選ぶようになりました。

> この動作は2進数の浮動小数点にとってはごく自然なものです。これは Python のバグではありませんし、あなたのコードのバグでもありません。ハードウェアの浮動小数点演算をサポートしている全ての言語で同じ種類の問題を見つけることができます (いくつかの言語ではデフォルトの、あるいはどの出力モードを選んでも、この差を 表示 しないかもしれませんが)。

よりよい出力のために、文字列フォーマットを利用して有効桁数を制限した10進数表現を得ることができます:

```python
>>> format(math.pi, '.12g')  # give 12 significant digits
'3.14159265359'

>>> format(math.pi, '.2f')   # give 2 digits after the point
'3.14'

>>> repr(math.pi)
'3.141592653589793'
```

> これが、実際のコンピューター上の値の 表示 を丸めているだけの、いわば錯覚だということを認識しておいてください。

錯覚とまで言い切った。

## 誤差の誤差

> もう一つの錯覚を紹介します。例えば、0.1 が正確には 1/10 ではないために、それを3回足した値もまた正確には 0.3 ではありません:

```python
>>> .1 + .1 + .1 == .3
False
```

### [round()](https://docs.python.jp/3/library/functions.html#round)

> 0.1 はこれ以上 1/10 に近くなることができない値で、 0.3 もまた 3/10 に一番近い値なので、 round() 関数を使って計算前に丸めを行なっても意味がありません:

```python
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
```

> 数字が正確な値に最も近い値になっているとはいえ、 round() 関数を使って計算後の値を丸めることで、不正確な代わりに他の値と比較できるようになる事があります:
```python
>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
```

### 罠

> 2 進の浮動小数点数に対する算術演算は、このような意外性をたくさん持っています。 “0.1” に関する問題は、以下の “表現エラー” の章で詳細に説明します。 2 進法の浮動小数点演算にともなうその他のよく知られた意外な事象に関しては [The Perils of Floating Point](http://www.lahey.com/float.htm) を参照してください。

> 究極的にいうと、”容易な答えはありません”。ですが、浮動小数点数のことを過度に警戒しないでください！ Python の float 型操作におけるエラーは浮動小数点処理ハードウェアから受けついたものであり、ほとんどのマシン上では一つの演算あたり高々 2**53 分の 1 です。この誤差はほとんどの作業で充分以上のものですが、浮動小数点演算は 10 進の演算ではなく、浮動小数点の演算を新たに行うと、新たな丸め誤差の影響を受けることを心にとどめておいてください。

もはや少数値を扱うことは罠に他ならない。使ったらまずい状況と、大丈夫な状況を明確にできない以上、リスクがある。正確な計算ができない可能性があることがはっきりしている。どこからが「過度の警戒」にあたるのかの判断さえできないことがすでに大きなリスクである。それを理解するには十分な学習と、そのばその場での判断と対処が必要になるのだろう。正確性を求めるなら利用を避けるのが賢明なのだろう。float, doubleの2進数浮動少数点数の話である。

## 書式

> 異常なケースが存在する一方で、普段の浮動小数点演算の利用では、単に最終的な結果の値を必要な 10 進の桁数に丸めて表示するのなら、最終的には期待通りの結果を得ることになるでしょう。たいては str() で十分ですが、きめ細かな制御をしたければ、 書式指定文字列の文法 にある str.format() メソッドのフォーマット仕様を参照してください。

## [decimal](https://docs.python.jp/3/library/decimal.html#module-decimal)

> 正確な10進数表現が必要となるような場合には、 decimal モジュールを利用してみてください。このモジュールは会計アプリケーションや高精度の計算が求められるアプリケーションに適した、10進数の計算を実装しています。

## [fractions](https://docs.python.jp/3/library/fractions.html#module-fractions)

> 別の正確な計算方法として、 fractions モジュールが有理数に基づく計算を実装しています (1/3 のような数を正確に表すことができます)。

## [SciPy](https://scipy.org/)

> あなたが浮動小数点演算のヘビーユーザーなら、SciPy プロジェクトが提供している Numerical Python パッケージやその他の数学用パッケージを調べてみるべきです。 <https://scipy.org> を参照してください。

## [float.as_integer_ratio()](https://docs.python.jp/3/library/stdtypes.html#float.as_integer_ratio)

> Python は 本当に float の正確な値が必要なレアケースに対応するためのツールを提供しています。 float.as_integer_ratio() メソッドは float の値を有理数として表現します:

```python
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
```
```python
>>> x == 3537115888337719 / 1125899906842624
True
```

## [float.hex()](https://docs.python.jp/3/library/stdtypes.html#float.hex)

> float.hex() メソッドは float の値を16進数で表現します。この値もコンピューターが持っている正確な値を表現できます:

```python
>>> x.hex()
'0x1.921f9f01b866ep+1'
```

この正確な16進数表現はもとの float 値を正確に復元するために使うことができます:

```python
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
```

> この16進数表現は正確なので、値を (プラットフォームにも依存せず) バージョンの異なるPython 間でやり取りしたり、他のこのフォーマットをサポートした言語 (Java や C99 など) と正確にやり取りするのに利用することができます。

## [math.fsum()](https://docs.python.jp/3/library/math.html#math.fsum)

> 別の便利なツールとして、合計処理における精度のロスを緩和してくれる math.fsum() 関数があります。この関数は値を合計値に足し込みながら、 “失われた桁” を管理します。これにより、誤差が最終的な合計値に影響を与えるまで蓄積されなくなり、結果が改善されます:

```python
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
```

