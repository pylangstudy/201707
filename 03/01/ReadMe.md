# [15.1. 表現エラー](https://docs.python.jp/3/tutorial/floatingpoint.html#representation-error)

< [15. 浮動小数点演算、その問題と制限](https://docs.python.jp/3/tutorial/floatingpoint.html#floating-point-arithmetic-issues-and-limitations) < [Python チュートリアル](https://docs.python.jp/3/tutorial/index.html) < [ドキュメント](https://docs.python.jp/3/index.html)

> この章では、”0.1” の例について詳細に説明し、このようなケースに対してどのようにすれば正確な分析を自分で行えるかを示します。ここでは、 2 進法表現の浮動小数点数についての基礎的な知識があるものとして話を進めます。

## 表現エラー

> 表現エラー(Representation error)は、いくつかの (実際にはほとんどの) 10 進の小数が 2 進法 (基数 2)の分数として表現できないという事実に関係しています。これは Python (あるいは Perl, C, C++, Java, Fortran. およびその他多く) が期待通りの正確な 10 進数を表示できない主要な理由です。

> なぜこうなるのでしょうか？ 1/10 は 2 進法の小数で厳密に表現することができません。今日 (2000年11月) のマシンは、ほとんどすべて IEEE-754 浮動小数点演算を使用しており、ほとんどすべてのプラットフォームでは Python の浮動小数点を IEEE-754 における “倍精度(double precision)” に対応付けます。754 の double には 53 ビットの精度を持つ数が入るので、計算機に入力を行おうとすると、可能な限り 0.1 を最も近い値の分数に変換し、J/2**N の形式にしようと努力します。J はちょうど 53 ビットの精度の整数です

```python
1 / 10 ~= J / (2**N)
```
```python
J ~= 2**N / 10
```

> J は厳密に 53 ビットの精度を持っている (>= 2**52 だが < 2**53 ) ことを思い出すと、 N として最適な値は 56 になります:

```python
>>> 2**52 <=  2**56 // 10  < 2**53
True
```

> すなわち、56 は J をちょうど 53 ビットの精度のままに保つ N の唯一の値です。J の取りえる値はその商を丸めたものです:

```python
>>> q, r = divmod(2**56, 10)
>>> r
6
```
> 剰余が 10 の半分以上なので、最良の近似は切り上げて丸めたものになります。
```python
>>>

>>> q+1
7205759403792794
```

> 従って、754 倍精度における 1/10 の取りえる最良の近似は:

```python
7205759403792794 / 2 ** 56
```

> 分子と分母を2で割って分数を小さくします:

```python
3602879701896397 / 2 ** 55
```

> 丸めたときに切り上げたので、この値は実際には 1/10 より少し大きいことに注目してください。 もし切り捨てをした場合は、商は 1/10 よりもわずかに小さくなります。どちらにしろ 厳密な 1/10 ではありません！

> つまり、計算機は 1/10 を “理解する” ことは決してありません。計算機が理解できるのは、上記のような厳密な分数であり、 754 の倍精度浮動小数点数で得られるもっともよい近似は以下になります:

```python
>>> 0.1 * 2 ** 55
3602879701896397.0
```

> この分数に 10**55 を掛ければ、55 桁の十進数の値を見ることができます:

```python
>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
```

> これは、計算機が記憶している正確な数値が、10 進数値 0.1000000000000000055511151231257827021181583404541015625 にほぼ等しいということです。多くの言語 (古いバージョンの Python を含む) では、完全な 10 進値を表示するのではなく、結果を有効数字 17 桁に丸めます:

```python
>>> format(0.1, '.17f')
'0.10000000000000001'
```

## [fractions](https://docs.python.jp/3/library/fractions.html#module-fractions), [decimal](https://docs.python.jp/3/library/decimal.html#module-decimal)

```python
>>> from decimal import Decimal
>>> from fractions import Fraction

>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)

>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)

>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')

>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'
```

