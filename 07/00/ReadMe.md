# [3.1. オブジェクト、値、および型](https://docs.python.jp/3/reference/datamodel.html#objects-values-and-types)

< [3. データモデル](https://docs.python.jp/3/reference/datamodel.html#data-model) < [ドキュメント](https://docs.python.jp/3/index.html)

## オブジェクト

> Python における オブジェクト (object) とは、データを抽象的に表したものです。Python プログラムにおけるデータは全て、オブジェクトまたはオブジェクト間の関係として表されます。(ある意味では、プログラムコードもまたオブジェクトとして表されます。これはフォン・ノイマン: Von Neumann の “プログラム記憶方式コンピュータ: stored program computer” のモデルに適合します。)

「Pythonではすべてがオブジェクトである」というやつか。

### 同一性

> すべての属性は、同一性 (identity)、型、値をもっています。 同一性 は生成されたあとは変更されません。これはオブジェクトのアドレスのようなものだと考えられるかもしれません。 ‘is‘ 演算子は2つのオブジェクトの同一性を比較します。 id() 関数は同一性を表す整数を返します。

> CPython 実装の詳細: CPython では、id(x) は x が格納されているメモリ上のアドレスを返します。

#### 検証1

```python
a = 100
b = 100
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a))
print(id(b))
```
```sh
$ python 0.py 
True
True
True
137280592
137280592
```

予想外の結果。`a == b`のみTrueになり他はFalseになるはずでは？`a is b`がTrueだとすると、aとbは同じオブジェクトを指すということになるのだが……。aとbは別のオブジェクトではないのか？個別に宣言し、`a = b`のような代入もしていないのになぜ同一になる？

考えられる理由は以下。どれも根拠なき妄想。

* ドキュメントが嘘
    * じつは`is`や`id()`は`==`と同じ結果になるだけの別名定義にすぎない？
    * じつは数値はオブジェクトではない？
        * だから値さえ同じなら`is`, `id()`が同一になる、というのは理由にならない
        * だったら数値は何なの？
* a, bは"属性"ではない？
    * `__main__`モジュールの属性とかだと思い込んでいるのだが違うのか？
    * 属性でないならa, bは何なのか？
* じつはPythonにはメモリ節約機能がある？
    * 同じ型、同じ値の場合、Python内部で1つの状態のみメモリ確保する
        * 各変数でそれを参照させる
        * 状態が変化したら改めて別メモリ確保する

#### 検証2

aとbの値を変えてみる。

```python
a = 100
b = 101
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a))
print(id(b))
```
```sh
$ python 1.py 
False
False
False
137280592
137280608
```

値が変わるのは当然として、今度はアドレスも変わった。元より別アドレスになるのが当然だと思っていたわけだが。同じ型、同じ値だと、同じメモリを共有するようになっている説が信憑性を増した。

#### 検証3,4

検証1,2と同じことをstr型でも試したが、同様の結果だった。`a='a', b='a'`は同一アドレスになり、`a='a', b='b'`は別アドレスになった。

```python
a = 'a'
b = 'a'
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a))
print(id(b))
```
```sh
$ python 2.py
True
True
True
3071794048
3071794048
```

```python
a = 'a'
b = 'b'
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a))
print(id(b))
```
```sh
$ python 3.py
False
False
False
3071056768
3071386560
```

#### 検証5

自作クラスで試したら期待に近い結果が出た。どうやら自作クラスだと別オブジェクトとして認識するらしい。

```python
class MyClass: pass
a = MyClass()
b = MyClass()
print(a == b)
print(a is b)
print(id(a) == id(b))
print(id(a))
print(id(b))
```
```sh
$ python 4.py
False
False
False
3072007372
3072007628
```

結果を見るに、自作クラスでは`==`での比較はできないと考えるべきか。おそらく演算子のオーバーロードが必要なのだろう。

#### 検証まとめ

結論：自作型(class)の場合は`is`, `id()`で異なるインスタンスとして確認できる。しかし、int, str型では値が同一の場合はインスタンスも同一のものを参照すると思われる

* すべてがオブジェクトである
* すべての属性は、同一性をもっている
    * 同一性 は生成後は変更されない

上記の条件から「すべての変数は異なる同一性を持っている」と考えていた。おそらくそのとおりなのだろうが、変数のアドレス自体はPythonでは参照しないのだろう。C言語的に考えると、Pythonではすべての変数がポインタ変数なのだろう。値を参照するのではなく、アドレスを参照する。比較も然り。ただ、intやstrは値が同じものが既に存在した場合、それと同じ参照先として勝手に設定されるのだろう。同じ値(状態)のメモリを複数作るのはメモリ効率が悪いということか。

ただ、そんな説明はPython文書のどこにも書いていない。そう考えれば私の中で理解できるというだけ。実態は知らない。





### 型(type)

> オブジェクトの型はオブジェクトがサポートする操作 (例: len() をサポートするか) と、オブジェクトが取りうる値を決定します。 type() 関数はオブジェクトの型 (型自体もオブジェクトです) を返します。同一性と同じく、オブジェクトの型(type) も変更不可能です。 [1]

```python
class MyClass: pass
n = 100
s = 'a'
c = MyClass()
print(type(n))
print(type(s))
print(type(c))
```
```sh
$ python 6.py
<class 'int'>
<class 'str'>
<class '__main__.MyClass'>
```

### 変更性

> オブジェクトによっては 値 を変更することが可能です。値を変更できるオブジェクトのことを mutable と呼びます。生成後に値を変更できないオブジェクトのことを immutable と呼びます。(mutable なオブジェクトへの参照を格納している immutableなコンテナオブジェクトの値は、その格納しているオブジェクトの値が変化した時に変化しますが、コンテナがどのオブジェクトを格納しているのかが変化しないのであれば immutable だと考えることができます。したがって、immutable かどうかは値が変更可能かどうかと完全に一致するわけではありません) オブジェクトが mutable かどうかはその型によって決まります。例えば、数値型、文字列型とタプル型のインスタンスは immutable で、dict や list は mutable です。

チュートリアルでは、listが変更可能(mutable)で、tupleが変更不可(immutable)とあった。immutableはC#など別の言語でいうReadOnlyと同じ概念だろうか？

本文`（）`内はわかりにくい。おそらく次のような意味だろう。いかにimmutableといえど、それが参照しているものがmutableであったなら、mutableな部分は変更されうる。外部で変更されたらその影響を受けて変更されるということだろう。いわゆる浅いコピーと深いコピーのうち、浅いコピーに当たると思われる。

### 破壊

> オブジェクトを明示的に破壊することはできません; しかし、オブジェクトに到達不能 (unreachable) になると、ガベージコレクション (garbage-collection) によって処理されます。実装では、ごみ収集を遅らせたり、全く行わないようにすることができます — 到達可能なオブジェクトをごみ収集処理してしまわないかぎり、どう実装するかは実装品質の問題です。

オブジェクトの破壊とは何を指しているのかわからないが、文脈的にメモリ解放のことだろうか？たしか`del 変数`とすると可能だったと[チュートリアル](https://docs.python.jp/3/tutorial/datastructures.html#the-del-statement)で見かけたが？

#### ガベージコレクション

> CPython 実装の詳細: 現在の CPython 実装では参照カウント(reference-counting) 方式を使っており、(オプションとして) 循環参照を行っているごみオブジェクトを遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると同時に処理することができますが、循環参照を含むごみオブジェクトの収集が確実に行われるよう保証しているわけではありません。循環参照を持つごみオブジェクト収集の制御については、 gc モジュールを参照してください。 CPython以外の実装は別の方式を使っており、CPythonも将来は別の方式を使うかもしれません。オブジェクトが到達不能になったときに即座に終了処理されることに頼らないでください (ですからファイルは必ず明示的に閉じてください)。

循環参照されると終了するまでメモリ解放されないということだろう。ファイルの終了処理を名指ししている。with文を使って終了するのが確実だろう。

#### try except

> 実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまうようなオブジェクトを生存させることがあるので注意してください。また、 ‘try...except‘ 文を使って例外を捕捉できるようにすると、オブジェクトを生存させることがあります。

どう注意すればいいのか？どうすれば確認、解放できるのか？何も書いていない……。

#### 外部リソース

> オブジェクトには、開かれたファイルやウィンドウといった、 “外部 (external) の” リソースへの参照を含むものがあります。これらのリソースは、オブジェクトがごみ収集された際に解放されるものと理解されていますが、ごみ収集が行われる保証はないので、こうしたオブジェクトは外部リソースを明示的に解放する方法、大抵は close() メソッドも提供しています。こうしたオブジェクトは明示的に close するよう強く奨めます。この操作をする際には、’try...finally‘ 文や、 ‘with‘ 文を使うと便利です。

#### コンテナ

> 他のオブジェクトに対する参照をもつオブジェクトもあります; これらは コンテナ (container) と呼ばれます。コンテナオブジェクトの例として、タプル、リスト、および辞書が挙げられます。オブジェクトへの参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値というと、コンテナに入っているオブジェクトの値のことを指し、それらオブジェクトのアイデンティティではありません; しかしながら、コンテナの変更可能性について述べる場合、今まさにコンテナに入っているオブジェクトのアイデンティティのことを指します。したがって、 (タプルのように) 変更不能なオブジェクトが変更可能なオブジェクトへの参照を含む場合、その値が変化するのは変更可能なオブジェクトが変更された時、ということになります。

## 同一性の確認方法

> 型はオブジェクトの動作のほとんど全てに影響します。オブジェクトのアイデンティティが重要かどうかでさえ、ある意味では型に左右されます: 変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ型と値を持った既存のオブジェクトへの参照を返すことがありますが、変更可能なオブジェクトではそのような動作は起こりえません。例えば、 a = 1; b = 1 とすると、 a と b は値 1 を持つ同じオブジェクトを参照するときもあるし、そうでないときもあります。これは実装に依存します。しかし、 c = []; d = [] とすると、 c と d はそれぞれ二つの異なった、互いに一意な、新たに作成された空のリストを参照することが保証されています。 (c = d = [] とすると、 c と d の両方に同じオブジェクトを代入します)

先述の疑問には最後に答えがあった。結論から最初に書いて欲しかった。どうやら実装依存の現象らしい。なおさら使うべきでない。

* immutableな型は`is`, `id()`で比較すると別のつもりが同一と判定されることがある（実装依存）
    * immutableな変数に対して`is`, `id()`で比較して同一確認すべきでない
        * 事実上、immutableな変数では確実な同一確認はできない

## 結論

同一性の確認方法は変更可能性ごとに異なる。

* 変更不可(immutable): 値の一致確認をもって同一か否かを判断する。アドレスでの一致確認は実装依存なので不確実。用いるべきでない。
* 変更可(mutable): アドレスの一致確認をもって同一か否かを判断する。値での一致確認は演算子オーバーロードが必要と思われる

型ごとの変更可能性はたとえば以下。

* immutable
    * 数値型
    * 文字列型
    * タプル型
* mutable
    * dict
    * list
    * 自作class(`class MyClass: pass`)

